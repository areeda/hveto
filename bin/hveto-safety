#!/usr/bin/env python
# vim: nu:ai:ts=4:sw=4

#
#  Copyright (C) 2019 Joseph Areeda <joseph.areeda@ligo.org>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Main program to run safety studies."""

from __future__ import (division, print_function)
import matplotlib
matplotlib.use('Agg')

import collections
import logging
import os
from shutil import copyfile
import subprocess
import time

try:
    import configparser
except ImportError:  # python 2.x
    import ConfigParser as configparser

from astropy.table import vstack as vstack_tables
from astropy.time import Time
from numpy import unique
from collections import OrderedDict

from gwpy.segments import (Segment, SegmentList,
                           DataQualityFlag, DataQualityDict)
from gwpy.time import tconvert

from gwdetchar import cli

from hveto.core import (coinc_significance, find_all_coincidences,
                        HvetoWinner, significance, find_coincidences,
                        HvetoRound, veto)
from hveto import (__version__, config, core, plot, html, utils)
from hveto.triggers import (get_triggers, find_auxiliary_channels)
from hveto.safety_html import (write_hveto_safety_page, write_safety_round)

from hveto.safety_plotter import inj_comp_plot
from hveto.safety_reader import safety_h5_read
from gwdetchar.io.html import (OBSERVATORY_MAP, FancyPlot, cis_link)
from hveto.plot import (HEADER_CAPTION, ROUND_CAPTION, get_column_label)


__author__ = 'joseph areeda <joseph.areeda@ligo.org>'
__version__ = '0.1.0'
__process_name__ = os.path.basename(__file__)

__credits__ = 'Joshua Smith <joshua.smith@ligo.org>, ' \
              'Duncan Macleod <duncan.macleod@ligo.org>, ' \
              'Alexander Urban <alexander.urban@ligo.org>'

# Global variables
primary = dict()
auxiliary = dict()

def safety_find_all_coincidences(primary, auxiliary, snrs, windows, live_time):
    """Compare each aux channel against primary for each snr, window
     return a  dictionary with one entry per channel for highest (snr, win)
     """
    ret = dict()
    prim_chan = list(primary.keys())[0]
    prim_evts = primary[prim_chan]
    prim_time = prim_evts['time']

    for chan, evts in auxiliary.items():
        cur_sig = 0
        for snr in snrs:
            aux_time = evts[evts['snr'] > snr]['time']
            for win in windows:
                coincs, sig = coinc_significance(prim_time, aux_time, win,
                                                 live_time)
                if sig > cur_sig:
                    try:
                        prob = prim_time.size * win / live_time
                    except ZeroDivisionError:
                        prob = 0
                    mu = prob * aux_time.size

                    coinc_tbl = prim_evts[coincs]
                    tmp = {'coincs': coinc_tbl, 'win': win, 'snr': snr,
                           'significance': sig, 'mu': mu}
                    cur_sig = sig
        if cur_sig > 0:
            ret[chan] = tmp
    ret = OrderedDict(sorted(ret.items(), key=lambda x: x[1]['significance'],
                             reverse=True))
    return ret

def safety_calc(cp, logger, outdir, inifile,
                ifo, start, end,  jobstart):
    """
    Calculate significance for each channel
    :param cp: configuration parameters
    :param logger: logging object

    :param outdir: html, configs ...

    :param ifo:
    :param start:
    :param end:
    :param jobstart: start time for reporting
    :return: stat [true if successful]
    """

    stat = False
    # >= cutoff -> unsafe
    safety_cutoff = cp.getfloat('safety', 'safety_cutoff')
    # plot if significance >= min
    safety_min = cp.getfloat('safety', 'safety_min')

    logger.debug('Safety params: safety_cutoff: {:.2f}, safety_min: {:.2f}'.
                 format(safety_cutoff, safety_min))

    ROUND_CAPTION['inj'] = 'Injection time comparision of primary and ' \
                           'auxiliary channel triggers. ' \
                           'First picture: Frequency versus time ' \
                            'graph of all triggers in the primary channel ' \
                            'before this hveto round (dots colored by ' \
                            'signal-to-noise ratio) and those triggers that ' \
                            'are vetoed by this round (red plusses). ' \
                            'Second picture: Freuquency versus time graph ' \
                            'of the auxiliary channel triggers before this ' \
                            'round (dots colored by signal-to-noise ratio), ' \
                            'those above the threshold selected for this ' \
                            'round (yellow plusses, these are the triggers ' \
                            'used to construct the veto), and those ' \
                            'triggers that actually veto one of the ' \
                            'primary channel triggers (red plusses).'

    ROUND_CAPTION['anim'] = 'Animation to see which triggers were used or ' \
                            'missed. First picture: Frequency versus time ' \
                            'graph of all triggers in the primary channel ' \
                            'before this hveto round (dots colored by ' \
                            'signal-to-noise ratio) and those triggers that ' \
                            'are vetoed by this round (red plusses). ' \
                            'Second picture: Freuquency versus time graph ' \
                            'of the auxiliary channel triggers before this ' \
                            'round (dots colored by signal-to-noise ratio), ' \
                            'those above the threshold selected for this ' \
                            'round (yellow plusses, these are the triggers ' \
                            'used to construct the veto), and those ' \
                            'triggers that actually veto one of the ' \
                            'primary channel triggers (red plusses).'

    analysis = ifo + ':INJECTION'

    auxchannels = auxiliary.keys()

    slabel = r"Signal-to-noise ratio (SNR)"
    flabel = r"Frequency [Hz]"
    auxslabel = slabel
    auxflabel = flabel

    # column names
    tcol = 'time'
    fcol = 'frequency'
    scol = 'snr'

    auxtcol = tcol
    auxfcol = fcol
    auxscol = scol

    # get what we need from the config parameters
    petg = cp.get('primary', 'trigger-generator')
    psnr = cp.getfloat('primary', 'snr-threshold')
    pfreq = cp.getfloats('primary', 'frequency-range')
    channel = cp.get('primary', 'channel')

    snrs = cp.getfloats('hveto', 'snr-thresholds')
    minsnr = min(snrs)
    windows = cp.getfloats('hveto', 'time-windows')

    _unsafe = cp.get('safety', 'unsafe-channels')
    _unsafe = _unsafe.replace('-', '_')
    unsafe = set(_unsafe.strip('\n').split('\n'))

    safety_cutoff = cp.getfloat('safety', 'safety_cutoff')
    safety_max_rounds = cp.getfloat('safety', 'safety_max_rounds')
    live_time = float(end - start)

    chan_num = 0

    # Convert dictionaries of event tables to 1 table
    # NB: channel name is one column
    pri_list = list(primary.values())
    aux_list = list(auxiliary.values())
    rec = vstack_tables(pri_list+aux_list)
    all_chan_results = safety_find_all_coincidences(primary, auxiliary, snrs,
                                                    windows, live_time)

    chan_stats = []
    rounds = []
    duration = end - start
    aux_stack = vstack_tables(aux_list)
    prim_chan = list(primary.keys())[0]
    prim_as_tbl = primary[prim_chan]

    qcdir = os.path.join(outdir, 'qcplots')
    os.makedirs(qcdir, exist_ok=True)

    inj_strt = prim_as_tbl['time'].min()
    inj_last = prim_as_tbl['time'].max()
    tlim = [inj_strt -30, inj_last+30]
    inj_fmax = prim_as_tbl['frequency'].max()
    flim = [0, inj_fmax+100]

    prim_qcplot = plot_table(prim_as_tbl, prim_chan, '.', tlim,
                             ylim=flim, epoch=inj_strt)
    if args.qcplot:
        for aux_chan in auxiliary.keys():
            plot_table(auxiliary[aux_chan], aux_chan, qcdir, tlim)

    plotdir = os.path.join('.', 'plots')  # results
    os.makedirs(plotdir, exist_ok=True)

    coincdir = os.path.join('.', 'coinc')  # any coincident
    os.makedirs(coincdir, exist_ok=True)

    trigdir = os.path.join('.', 'triggers')  # any coincident
    os.makedirs(trigdir, exist_ok=True)

    # ascii results
    sum_file = outdir + "/safety_summary.csv"

    with open(sum_file, 'w') as summary_csv:

        for chan, results in all_chan_results.items():
            dt = results['win']
            snr = results['snr']
            sig = results['significance']
            coinc1 = results['coincs']
            trig_cnt = len(coinc1)
            mu = results['mu']

            if trig_cnt > 0:
                # save vals for every channel. here everyone is a winner
                chan_stat = HvetoWinner(name=chan)

                chan_stat.snr = snr
                chan_stat.window = dt
                chan_stat.significance = sig
                chan_stat.mu = mu
                chan_stat.ncoinc = trig_cnt

                chan_stats.append(chan_stat)
            else:
                logger.info('{:s} had zero trigger coincidences'.
                            format(chan))

            # CSV column name
            vals = 'chan, significance, N-coinc, N-expected, N-aux, ' \
                   'N-coinc/N-expected, SNR, dT, was unsafe, is unsafe '
            print(vals, file=summary_csv)

            name = chan_stat.name

            allaux = auxiliary[name][auxiliary[name]['snr'] >= chan_stat.snr]

            chan_stat.ncoinc = trig_cnt
            chan_stat.significance = sig
            chan_num += 1

            was_safe  = 'Unsafe' if name in _unsafe else 'Safe'
            is_safe = 'Unsafe' if sig > safety_cutoff else 'Safe'

            expected = chan_stat.ncoinc / chan_stat.mu \
                if chan_stat.mu != 0 else 0;

            vals = '%s,%.3f,%d,%.3f,%.0f,%.4f,%.1f,%.2f,%s, %s' %\
                   (name, chan_stat.significance, chan_stat.ncoinc,
                    chan_stat.mu, len(allaux), expected, chan_stat.snr,
                    chan_stat.window, was_safe, is_safe)
            print(vals, file=summary_csv)

            if sig > safety_min and chan_num <= safety_max_rounds:

                # process as if it were a round winner
                round = HvetoRound(chan_num, prim_as_tbl)
                round.segments = analysis_seg.active
                # work out the vetoes for this round

                chan_stat.events = allaux
                round.vetoes = chan_stat.get_segments(allaux['time'])
                flag = DataQualityFlag('%s:HVT-CHAN_%d:1' % (ifo, round.n),
                                       active=round.vetoes,
                                       known=round.segments,
                                       description=f'winner={chan_stat.name}, '
                                       f'window={chan_stat.window}, snr={chan_stat.snr}')
                before = prim_as_tbl
                beforeaux = auxiliary[chan_stat.name]

                # we calculate but don't apply vetoes to primary
                primary_vetoed, vetoed = veto(prim_as_tbl, round.vetoes)

                aux_vetoed, avetoed = veto(beforeaux, round.vetoes)

                round.winner = chan_stat
                winner = chan_stat
                round.efficiency = (len(vetoed), len(primary_vetoed) +
                                    len(vetoed))
                round.use_percentage = (len(coinc1), len(chan_stat.events))
                round.cum_efficiency = round.efficiency
                round.cum_deadtime = round.deadtime

                # write triggers
                trigfile = os.path.join(trigdir,
                                        '%s-HVETO_%%s_TRIGS_ROUND_%d-%d-%d.txt'
                                        % (ifo, round.n, start, duration))
                for tag, arr in zip(
                        ['VETOED', 'COINCS'],
                        [vetoed, coinc1]):
                    trig_fname = trigfile % tag
                    arr.write(trig_fname, format='ascii', overwrite=True)
                    logger.debug("Round %d %s events written to %s"
                                 % (round.n, tag.lower(), trig_fname))
                    round.files[tag] = trig_fname
                round.n_coincs = len(coinc1)
                round.n_vetoed = len(vetoed)
                logger.debug('%4d. %s ' % (round.n, chan_stat.name))
                # log results
                logger.info('Results for round {:d}\n'
                            '    winner :          {:s}\n'
                            '    significance :    {:.2f}\n'
                            '    mu :              {:.3f}\n'
                            '    snr :             {:.2f}\n'
                            '    dt :              {:.2f}\n'
                            '    use_percentage :  {:}\n'
                            '    efficiency :      {:}\n'
                            '    deadtime :        {:}\n'.
                            format(
                                round.n, round.winner.name,
                                round.winner.significance,
                                round.winner.mu, round.winner.snr,
                                round.winner.window,
                                round.use_percentage,round.efficiency,
                                (' ,'.join(f'{x:.2f}' for x in round.deadtime))
                            ))
                pngname = os.path.join(plotdir, '%s-HVETO_%%s_SAFETY_'
                                                'ROUND_%03d-%d-%d.png' %
                                       (ifo, round.n, start, duration))
                if plot.rcParams['text.usetex']:
                    wname = round.winner.name.replace('_', r'\_')
                else:
                    wname = round.winner.name
                beforel = 'Before\n[%d]' % len(before)
                afterl = 'After\n[%d]' % len(primary_vetoed)
                vetoedl = 'Vetoed\n[%d]' % len(vetoed)
                beforeauxl = 'All\n[%d]' % len(beforeaux)
                usedl = 'Used\n[%d]' % len(chan_stat.events)
                coincl = 'Coinc.\n[%d]' % len(coinc1)
                title = '%s Hveto round %d, significance %.1f' % (
                    ifo, round.n, round.winner.significance)
                ptitle = '%s: primary impact' % title
                atitle = '%s: auxiliary use' % title
                subtitle = '[%d-%d] | winner: %s' % (start, end, wname)

                # before/after histogram
                png = pngname % 'HISTOGRAM'
                if not os.path.isfile(png):
                    plot.before_after_histogram(
                        png, before[scol], prim_as_tbl[scol],
                        label1=beforel, label2=afterl, xlabel=slabel,
                        title=ptitle, subtitle=subtitle)
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['HISTOGRAM'])
                round.plots.append(png)

                # snr versus time
                png = pngname % 'SNR_TIME'
                if not os.path.isfile(png):
                    plot.veto_scatter(png, before, vetoed, x='time',
                                      y=scol, label1=beforel,
                                      label2=vetoedl, epoch=start,
                                      xlim=[start, end],
                                      ylabel=slabel, title=ptitle,
                                      subtitle=subtitle,
                                      legend_title="Primary:")
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['SNR_TIME'])
                round.plots.append(png)

                # snr versus frequency
                png = pngname % 'SNR_%s' % fcol.upper()
                if not os.path.isfile(png):
                    plot.veto_scatter(png, before, vetoed, x=fcol, y=scol,
                                      label1=beforel, label2=vetoedl,
                                      xlabel=flabel, ylabel=slabel,
                                      xlim=pfreq, title=ptitle,
                                      subtitle=subtitle,
                                      legend_title="Primary:")
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['SNR'])
                round.plots.append(png)

                # frequency versus time coloured by SNR
                png = pngname % '%s_TIME' % fcol.upper()
                if not os.path.isfile(png):
                    plot.veto_scatter(
                        png, before, vetoed, x='time', y=fcol, color=scol,
                        label1=None, label2=None, ylabel=flabel,
                        clabel=slabel, clim=[3, 100], cmap='YlGnBu',
                        epoch=start, xlim=[start, end], ylim=pfreq,
                        title=ptitle, subtitle=subtitle)
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['TIME'])
                round.plots.append(png)

                # aux used versus frequency
                png = pngname % 'USED_SNR_TIME'
                if not os.path.isfile(png):
                    plot.veto_scatter(png, chan_stat.events, vetoed, x='time',
                                      y=[auxscol, scol], label1=usedl,
                                      label2=vetoedl, ylabel=slabel,
                                      epoch=start, xlim=[start, end],
                                      title=atitle, subtitle=subtitle)
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['USED_SNR_TIME'])
                round.plots.append(png)

                # snr versus time
                png = pngname % 'AUX_SNR_TIME'
                if not os.path.isfile(png):
                    plot.veto_scatter(
                            png, beforeaux, (chan_stat.events, coinc1), x='time',
                            y=auxscol, label1=beforeauxl,
                            label2=(usedl, coincl), epoch=start,
                            xlim=[start, end], ylabel=auxslabel,
                            title=atitle, subtitle=subtitle)
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png, caption=ROUND_CAPTION['AUX_SNR_TIME'])
                round.plots.append(png)

                # snr versus frequency
                png = pngname % 'AUX_SNR_FREQUENCY'
                if not os.path.isfile(png):
                    plot.veto_scatter(
                            png, beforeaux, (chan_stat.events, coinc1), x=auxfcol,
                            y=auxscol, label1=beforeauxl,
                            label2=(usedl, coincl), xlabel=auxflabel,
                            ylabel=auxslabel, title=atitle,
                            subtitle=subtitle, legend_title="Aux:")
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png,
                                caption=ROUND_CAPTION['AUX_SNR_FREQUENCY'])
                round.plots.append(png)

                # frequency versus time coloured by SNR
                png = pngname % 'AUX_FREQUENCY_TIME'
                if not os.path.isfile(png):
                    plot.veto_scatter(
                            png, beforeaux, (chan_stat.events, coinc1), x='time',
                            y=auxfcol, color=auxscol, label1=None,
                            label2=[None, None], ylabel=auxflabel,
                            clabel=auxslabel, clim=[3, 100], cmap='YlGnBu',
                            epoch=start,
                            xlim=[start, end], title=atitle,
                            subtitle=subtitle)
                    logger.debug("Figure written to %s" % png)
                png = FancyPlot(png,
                                caption=ROUND_CAPTION['AUX_FREQUENCY_TIME'])
                round.plots.append(png)

                subp, anim = inj_comp_plot(name, prim_as_tbl, allaux,
                                           chan_stat.window, plotdir)
                png = FancyPlot(subp, caption=ROUND_CAPTION['inj'])
                round.plots.append(png)

                png = FancyPlot(anim, caption=ROUND_CAPTION['anim'])
                round.plots.append(png)

                munged_name = round.winner.name.replace('-', '_')
                round.unsafe = munged_name  in unsafe

                rounds.append(round)
            # end of round processing, any channels left over
            nused = len(olddir)
            remaining = list()
            for name in auxchannels:
                if not name in all_chan_results.keys():
                    was_safe = 'Unsafe' if name in _unsafe else 'Safe'
                    is_safe = 'Safe'
                    allaux = auxiliary[name]

                    vals = '%s,%.3f,%d,%.3f,%.0f,%.4f,%.1f,%.2f,%s, %s' % \
                           (name, 0, 0, 0, len(allaux), 0, 0, 0, was_safe,
                            is_safe)
                    print(vals, file=summary_csv)

    # -- write HTML
    # prepare html variables
    start_utc = tconvert(start)
    end_utc = tconvert(end)
    timeStr = '{:s} - {:s}'.format(str(start_utc), str(end_utc))

    title_txt = '%s Hveto Safety  %d-%d (%s)' % (ifo, start, end, timeStr)

    htmlv = {
        'title': title_txt,
        'config': None,
    }
    if isinstance(inifile, list):
         htmlv['config'] = inifile[0]
    else:
        htmlv['config'] = inifile

    htmlv['inj_img'] = prim_qcplot

    index = write_hveto_safety_page(ifo, start, end, rounds,
                                    safety_cutoff, **htmlv)
    htmlv.pop('inj_img')
    logger.debug("HTML written to %s" % index)

    htmlv['write_about_file'] = False
    for r in rounds:
        if r.winner.significance >= safety_min:
            htmlv['base'] = './'
            htmlv['html_file'] = 'hveto-round-%04d-summary.html' % r.n
            write_safety_round(ifo, start, end, r, safety_cutoff, **htmlv)
            logger.info('Round %d html written' % r.n)

    run_time = time.time() - jobstart
    logger.info('Wrote index to {:s}, in {:s}'.format(index, outdir))
    logger.info('Safety runtime  %.1f sec' % run_time)

    return stat


def abs_path(p):
    return os.path.abspath(os.path.expanduser(p))


def plot_table(tbl, name, qcpath, tlim, ylim=None, epoch=None):
    """Event table plotter for examples"""
    qcplot = tbl.scatter('time', 'frequency', color='snr', vmin=0, vmax=75)
    ax = qcplot.gca()
    qcplot.suptitle(name, fontsize=18)
    ax.grid(b=True, which='major', color='k', linestyle='solid')
    ax.grid(b=True, which='minor', color='0.06', linestyle='dotted')
    ax.colorbar(label='SNR')
    ax.set_xlim(tlim[0], tlim[1])
    if ylim:
        ax.set_ylim(ylim[0], ylim[1])
    else:
        ax.set_ylim(0, 2048)

    if epoch:
        ax.set_epoch(epoch)

    ax.set_ylabel('Frequency (Hz)')

    fname = name.replace(':', '-') + '.png'
    outfile = os.path.join(qcpath, fname)
    qcplot.savefig(outfile, edgecolor='white', bbox_inches='tight')
    return outfile

if __name__ == "__main__":
    IFO = os.getenv('IFO')

    logger = cli.logger(__process_name__)
    start_time = time.time()
    parser = cli.create_parser(description=__doc__, version=__version__)
    cli.add_ifo_option(parser, required=IFO is None, ifo=IFO)

    parser.add_argument('-v', '--verbose', action='count', default=1,
                        help='increase verbose output')
    parser.add_argument('-q', '--quiet', default=False, action='store_true',
                        help='show only fatal errors')

    cin = parser.add_argument_group('Control options')

    parser.add_argument('-f', '--config-file', action='append', default=[],
                        type=abs_path,
                        help='path to hveto configuration file, can be given '
                             'multiple times (files read in order)')

    cli.add_gps_start_stop_arguments(cin)
    cin.add_argument('-Q', '--qcplot', action='store_true',
                     help='Plot triggers for all input channels')

    pin = parser.add_argument_group('Input options')
    parser.add_argument('-S', '--segment', default=None, type=abs_path,
                        required=True,
                        help='path to segment covering analysis in xml file')
    parser.add_argument('-p', '--primary', default=None, type=abs_path,
                        help='path to primary channel in an hdf5 file')
    parser.add_argument('-a', '--auxiliary', default=None, type=abs_path,
                        help='path to hdf5 file containing all '
                             'auxiliary channel triggers. ')

    pout = parser.add_argument_group('Output options')
    pout.add_argument('-o', '--output-directory',
                      default=os.path.abspath(os.curdir),
                      help='path of output directory, default: %(default)s')

    args = parser.parse_args()

    outdir = args.output_directory
    if os.path.exists(outdir):
        if not os.path.isdir(outdir):
            logger.error('Output directory specified {:s} exists but is not'
                         ' a directory.'.format(os.path.abspath(outdir)))
            raise TypeError('Not a directory')
    else:
        os.makedirs(outdir)

    fileHandler = logging.FileHandler(os.path.join(outdir, 'safety-log.txt'))
    logger.addHandler(fileHandler)

    # read configuration
    cp = config.HvetoConfigParser(ifo=args.ifo)
    cp.read(args.config_file)
    logger.info("Parsed configuration file(s)")

    primary_freq_range = cp.getfloats('primary', 'frequency-range')
    primary = safety_h5_read(args.primary, primary_freq_range)

    aux_freq_range = cp.getfloats('auxiliary', 'frequency-range')
    auxiliary = safety_h5_read(args.auxiliary, aux_freq_range)

    olddir = os.getcwd()
    os.chdir(outdir)

    analysis_seg = DataQualityFlag.read(args.segment)

    # copy input files to results
    copyfile(args.primary, os.path.join(outdir, 'primary.h5'))
    copyfile(args.auxiliary, os.path.join(outdir, 'auxiliary.h5'))
    copyfile(args.segment, os.path.join(outdir, 'segment.xml.gz'))

    safety_calc(cp, logger, outdir, args.config_file, args.ifo,
                args.gpsstart, args.gpsend, start_time)

    os.chdir(olddir)

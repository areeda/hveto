#!/usr/bin/env python
# vim: nu:ai:ts=4:sw=4

#
#  Copyright (C) 2019 Joseph Areeda <joseph.areeda@ligo.org>
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

"""Main program to run safety studies."""

from __future__ import (division, print_function)
import matplotlib
matplotlib.use('Agg')

import collections
import os
from shutil import copyfile
import subprocess
import time

try:
    import configparser
except ImportError:  # python 2.x
    import ConfigParser as configparser

from astropy.table import vstack as vstack_tables
from astropy.time import Time
from numpy import unique

from gwpy.segments import (Segment, SegmentList,
                           DataQualityFlag, DataQualityDict)
from gwpy.time import tconvert

from gwdetchar import cli

from hveto.core import (coinc_significance, find_all_coincidences,
                        HvetoWinner, significance, find_coincidences,
                        HvetoRound, veto)
from hveto import (__version__, config, core, plot, html, utils)
from hveto.triggers import (get_triggers, find_auxiliary_channels)
from hveto.safety_html import (write_hveto_safety_page, write_safety_round)


from hveto.safety_reader import safety_h5_read
from gwdetchar.io.html import (OBSERVATORY_MAP, FancyPlot, cis_link)
from hveto.plot import (HEADER_CAPTION, ROUND_CAPTION, get_column_label)


__author__ = 'joseph areeda <joseph.areeda@ligo.org>'
__version__ = '0.1.0'
__process_name__ = os.path.basename(__file__)

__credits__ = 'Joshua Smith <joshua.smith@ligo.org>, ' \
              'Duncan Macleod <duncan.macleod@ligo.org>, ' \
              'Alexander Urban <alexander.urban@ligo.org>'

# Global variables
primary = dict()
auxiliary = dict()


def safety_calc(cp, logger, outdir, inifile,
                ifo, start, end,  jobstart):
    """
    Calculate significance for each channel
    :param cp: configuration parameters
    :param logger: logging object

    :param outdir: html, configs ...

    :param ifo:
    :param start:
    :param end:
    :param jobstart: start time for reporting
    :return: stat [true if successful]
    """

    stat = False
    # >= cutoff -> unsafe
    safety_cutoff = cp.getfloat('safety', 'safety_cutoff')
    # plot if significance >= min
    safety_min = cp.getfloat('safety', 'safety_min')

    logger.debug('Safety params: safety_cutoff: {:.2f}, safety_min: {:.2f}'.
                 format(safety_cutoff, safety_min))

    analysis = ifo + ':INJECTION'

    auxchannels = auxiliary.keys()

    slabel = r"Signal-to-noise ratio (SNR)"
    flabel = r"Frequency [Hz]"
    auxslabel = slabel
    auxflabel = flabel

    # column names
    tcol = 'time'
    fcol = 'frequency'
    scol = 'snr'

    auxtcol = tcol
    auxfcol = fcol
    auxscol = scol

    # get what we need from the config parameters
    petg = cp.get('primary', 'trigger-generator')
    psnr = cp.getfloat('primary', 'snr-threshold')
    pfreq = cp.getfloats('primary', 'frequency-range')
    channel = cp.get('primary', 'channel')

    snrs = cp.getfloats('hveto', 'snr-thresholds')
    minsnr = min(snrs)
    windows = cp.getfloats('hveto', 'time-windows')

    _unsafe = cp.get('safety', 'unsafe-channels')
    _unsafe = _unsafe.replace('-', '_')
    unsafe = set(_unsafe.strip('\n').split('\n'))

    safety_cutoff = cp.getfloat('safety', 'safety_cutoff')
    safety_max_rounds = cp.getfloat('safety', 'safety_max_rounds')
    live_time = float(end - start)

    chan_num = 0

    # Convert dictionaries of event tables to 1 table
    # NB: channel name is one column
    pri_list = list(primary.values())
    aux_list = list(auxiliary.values())
    rec = vstack_tables(pri_list+aux_list)
    coincs = find_all_coincidences(rec, channel, snrs, windows)

    chan_stats = []
    rounds = []
    duration = end - start
    aux_stack = vstack_tables(aux_list)
    for k in primary.keys():    # there's only 1 but
        prim_as_tbl = primary[k]

    qcdir = os.path.join(outdir, 'qcplots')
    os.makedirs(qcdir, exist_ok=True)

    inj_strt = prim_as_tbl['time'].min()
    inj_last = prim_as_tbl['time'].max()
    tlim = [inj_strt -30, inj_last+30]
    inj_fmax = prim_as_tbl['frequency'].max()
    flim = [0, inj_fmax+100]
    prim_qcplot = plot_table(prim_as_tbl, k, '.', tlim,
                             ylim=flim, epoch=inj_strt)

    if args.qcplot:
        for k in auxiliary.keys():
            plot_table(auxiliary[k], k, qcdir, tlim)

    plotdir = os.path.join('.', 'plots') # results
    os.makedirs(plotdir, exist_ok=True)

    coincdir = os.path.join('.', 'coinc') # any coincident
    os.makedirs(coincdir, exist_ok=True)

    trigdir = os.path.join('.', 'triggers')  # any coincident
    os.makedirs(trigdir, exist_ok=True)

    sigs = dict((c, 0) for c in auxiliary)
    for p, cdict in coincs.items():
        dt, snr = p
        for chan in cdict:
            mu = (len(prim_as_tbl) * (auxiliary[chan]['snr'] >= snr).sum() *
                  dt / live_time)
            # NOTE: coincs[p][chan] counts the number of primary channel
            # triggers coincident with a 'chan' trigger
            try:
                this_chan = aux_stack[aux_stack['channel']==chan]
                allaux = this_chan[this_chan['snr'] >= snr]
                coinc1 = allaux[find_coincidences(allaux['time'],
                                                  prim_as_tbl['time'], dt=dt)]

                trig_cnt = len(coinc1)
                sig = significance(trig_cnt, mu)
            except KeyError:
                sig = 0
                trig_cnt = 0

            if trig_cnt > 0:
                # save vals for every channel. here everyone is a winner
                chan_stat = HvetoWinner(name=chan)

                chan_stat.snr = snr
                chan_stat.window = dt
                chan_stat.significance = sig
                chan_stat.mu = mu
                chan_stat.ncoinc = trig_cnt

                chan_stats.append(chan_stat)
            else:
                logger.info('{:s} had zero trigger coincidences'.
                            format(chan))
    # sort by significance
    chan_stats = sorted(chan_stats, key=lambda x: x.significance, reverse=True)

    # ascii results
    sum_file = outdir + "/safety_summary.csv"

    with open(sum_file, 'w') as f:
        # CSV column name
        vals = 'chan, significance, N-coinc, N-expected, '
        vals += 'N-aux, N-coinc/N-expected, SNR, dT, was unsafe, is unsafe '
        print(vals, file=f)

        old_names = set()
        for cs in chan_stats:
            name = cs.name
            if not name in old_names:
                # may have duplicate names with different time windows, snr
                # we are sorted by significanceso the one we want comes first
                old_names.add(name)
                allaux = auxiliary[name][auxiliary[name]['snr'] >= cs.snr]
                coincs = allaux[find_coincidences(allaux['time'],
                                                  prim_as_tbl['time'], dt=dt)]

                # recalc because of bug(?) in find_all_coincidences
                try:
                    trig_cnt = len(coincs)
                    sig = significance(trig_cnt, cs.mu) if trig_cnt > 0 else 0
                except KeyError:
                    sig == 0

                cs.ncoinc = trig_cnt
                cs.significance = sig
                chan_num += 1

                dups = [item for item, count in collections.Counter(
                        coincs['time']).items() if count > 1]

                dup_str = ''
                if len(dups) > 0:
                    dup_str = ','.join(map(str, coincs['time']))

                was_safe  = 'Unsafe' if name in _unsafe else 'Safe'
                is_safe = 'Unsafe' if sig > safety_cutoff else 'Safe'

                expected = cs.ncoinc / cs.mu if cs.mu != 0 else 0;

                vals = '%s,%.3f,%d,%.3f,%.0f,%.4f,%.1f,%.2f,%s, %s' %\
                       (name, cs.significance, cs.ncoinc, cs.mu,
                        len(allaux), expected, cs.snr,
                        cs.window, was_safe, is_safe)
                print(vals, file=f)

                if sig > safety_min and chan_num <= safety_max_rounds:

                    # process as if it were a round winner
                    round = HvetoRound(chan_num, prim_as_tbl)
                    round.segments = analysis_seg.active
                    # work out the vetoes for this round

                    cs.events = allaux
                    round.vetoes = cs.get_segments(allaux['time'])
                    flag = DataQualityFlag('%s:HVT-CHAN_%d:1' % (ifo, round.n),
                                           active=round.vetoes,
                                           known=round.segments,
                                           description=f'winner={cs.name}, '
                                           f'window={cs.window}, snr={cs.snr}')
                    before = prim_as_tbl
                    beforeaux = auxiliary[cs.name]

                    # we calculate but don't apply vetoes to primary
                    primary_vetoed, vetoed = veto(prim_as_tbl, round.vetoes)

                    aux_vetoed, avetoed = veto(beforeaux, round.vetoes)

                    round.winner = cs
                    winner = cs
                    round.efficiency = (len(vetoed), len(primary_vetoed) +
                                        len(vetoed))
                    round.use_percentage = (len(coincs), len(cs.events))
                    round.cum_efficiency = round.efficiency
                    round.cum_deadtime = round.deadtime

                    # write triggers
                    trigfile = os.path.join(trigdir,
                                            '%s-HVETO_%%s_TRIGS_ROUND_%d-%d-%d.txt'
                                            % (ifo, round.n, start, duration))
                    for tag, arr in zip(
                            ['VETOED', 'COINCS'],
                            [vetoed, coincs]):
                        trig_fname = trigfile % tag
                        arr.write(trig_fname, format='ascii', overwrite=True)
                        logger.debug("Round %d %s events written to %s"
                                     % (round.n, tag.lower(), trig_fname))
                        round.files[tag] = trig_fname
                    round.n_coincs = len(coincs)
                    round.n_vetoed = len(vetoed)
                    logger.debug('%4d. %s ' % (round.n, cs.name))
                    # log results
                    logger.info('Results for round %d\n'
                                '    winner :          %s\n'
                                '    significance :    %s\n'
                                '    mu :              %s\n'
                                '    snr :             %s\n'
                                '    dt :              %s\n'
                                '    use_percentage :  %s\n'
                                '    efficiency :      %s\n'
                                '    deadtime :        %s\n'
                                '    cum. efficiency : %s\n'
                                '    cum. deadtime :   %s' %
                        (
                        round.n, round.winner.name, round.winner.significance,
                        round.winner.mu, round.winner.snr, round.winner.window,
                        round.use_percentage, round.efficiency, round.deadtime,
                        round.cum_efficiency, round.cum_deadtime))

                    pngname = os.path.join(plotdir, '%s-HVETO_%%s_SAFETY_'
                                                    'ROUND_%03d-%d-%d.png' %
                                           (ifo, round.n, start, duration))
                    if plot.rcParams['text.usetex']:
                        wname = round.winner.name.replace('_', r'\_')
                    else:
                        wname = round.winner.name
                    beforel = 'Before\n[%d]' % len(before)
                    afterl = 'After\n[%d]' % len(primary_vetoed)
                    vetoedl = 'Vetoed\n[%d]' % len(vetoed)
                    beforeauxl = 'All\n[%d]' % len(beforeaux)
                    usedl = 'Used\n[%d]' % len(cs.events)
                    coincl = 'Coinc.\n[%d]' % len(coincs)
                    title = '%s Hveto round %d, significance %.1f' % (
                        ifo, round.n, round.winner.significance)
                    ptitle = '%s: primary impact' % title
                    atitle = '%s: auxiliary use' % title
                    subtitle = '[%d-%d] | winner: %s' % (start, end, wname)

                    # before/after histogram
                    png = pngname % 'HISTOGRAM'
                    if not os.path.isfile(png):
                        plot.before_after_histogram(
                            png, before[scol], prim_as_tbl[scol],
                            label1=beforel, label2=afterl, xlabel=slabel,
                            title=ptitle, subtitle=subtitle)
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['HISTOGRAM'])
                    round.plots.append(png)

                    # snr versus time
                    png = pngname % 'SNR_TIME'
                    if not os.path.isfile(png):
                        plot.veto_scatter(png, before, vetoed, x='time',
                                          y=scol, label1=beforel,
                                          label2=vetoedl, epoch=start,
                                          xlim=[start, end],
                                          ylabel=slabel, title=ptitle,
                                          subtitle=subtitle,
                                          legend_title="Primary:")
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['SNR_TIME'])
                    round.plots.append(png)

                    # snr versus frequency
                    png = pngname % 'SNR_%s' % fcol.upper()
                    if not os.path.isfile(png):
                        plot.veto_scatter(png, before, vetoed, x=fcol, y=scol,
                                          label1=beforel, label2=vetoedl,
                                          xlabel=flabel, ylabel=slabel,
                                          xlim=pfreq, title=ptitle,
                                          subtitle=subtitle,
                                          legend_title="Primary:")
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['SNR'])
                    round.plots.append(png)

                    # frequency versus time coloured by SNR
                    png = pngname % '%s_TIME' % fcol.upper()
                    if not os.path.isfile(png):
                        plot.veto_scatter(
                            png, before, vetoed, x='time', y=fcol, color=scol,
                            label1=None, label2=None, ylabel=flabel,
                            clabel=slabel, clim=[3, 100], cmap='YlGnBu',
                            epoch=start, xlim=[start, end], ylim=pfreq,
                            title=ptitle, subtitle=subtitle)
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['TIME'])
                    round.plots.append(png)

                    # aux used versus frequency
                    png = pngname % 'USED_SNR_TIME'
                    if not os.path.isfile(png):
                        plot.veto_scatter(png, cs.events, vetoed, x='time',
                                          y=[auxscol, scol], label1=usedl,
                                          label2=vetoedl, ylabel=slabel,
                                          epoch=start, xlim=[start, end],
                                          title=atitle, subtitle=subtitle)
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['USED_SNR_TIME'])
                    round.plots.append(png)

                    # snr versus time
                    png = pngname % 'AUX_SNR_TIME'
                    if not os.path.isfile(png):
                        plot.veto_scatter(
                                png, beforeaux, (cs.events, coincs), x='time',
                                y=auxscol, label1=beforeauxl,
                                label2=(usedl, coincl), epoch=start,
                                xlim=[start, end], ylabel=auxslabel,
                                title=atitle, subtitle=subtitle)
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png, caption=ROUND_CAPTION['AUX_SNR_TIME'])
                    round.plots.append(png)

                    # snr versus frequency
                    png = pngname % 'AUX_SNR_FREQUENCY'
                    if not os.path.isfile(png):
                        plot.veto_scatter(
                                png, beforeaux, (cs.events, coincs), x=auxfcol,
                                y=auxscol, label1=beforeauxl,
                                label2=(usedl, coincl), xlabel=auxflabel,
                                ylabel=auxslabel, title=atitle,
                                subtitle=subtitle, legend_title="Aux:")
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png,
                                    caption=ROUND_CAPTION['AUX_SNR_FREQUENCY'])
                    round.plots.append(png)

                    # frequency versus time coloured by SNR
                    png = pngname % 'AUX_FREQUENCY_TIME'
                    if not os.path.isfile(png):
                        plot.veto_scatter(
                                png, beforeaux, (cs.events, coincs), x='time',
                                y=auxfcol, color=auxscol, label1=None,
                                label2=[None, None], ylabel=auxflabel,
                                clabel=auxslabel, clim=[3, 100], cmap='YlGnBu',
                                epoch=start,
                                xlim=[start, end], title=atitle,
                                subtitle=subtitle)
                        logger.debug("Figure written to %s" % png)
                    png = FancyPlot(png,
                                    caption=ROUND_CAPTION['AUX_FREQUENCY_TIME'])
                    round.plots.append(png)

                    munged_name = round.winner.name.replace('-', '_')
                    round.unsafe = munged_name  in unsafe

                    rounds.append(round)
        # end of round processing, any channels left over
        nused = len(olddir)
        remaining = list()
        for name in auxchannels:
            if not name in old_names:
                old_names.add(name)
                was_safe = 'Unsafe' if name in _unsafe else 'Safe'
                is_safe = 'Unsafe' if sig > safety_cutoff else 'Safe'
                allaux = auxiliary[name]

                vals = '%s,%.3f,%d,%.3f,%.0f,%.4f,%.1f,%.2f,%s, %s' % \
                       (name, 0, 0, 0, len(allaux), 0, 0, 0, was_safe, is_safe)
                print(vals, file=f)

    # -- write HTML
    # prepare html variables
    startUTC = tconvert(start)
    endUTC = tconvert(end)
    timeStr = '{:s} - {:s}'.format(str(startUTC), str(endUTC))

    title_txt = '%s Hveto Safety  %d-%d (%s)' % (ifo, start, end, timeStr)

    htmlv = {
        'title': title_txt,
        'config': None,
    }
    if isinstance(inifile, list):
        htmlv['config'] = inifile[0]
    else:
        htmlv['config'] = inifile

    htmlv['inj_img'] = prim_qcplot

    index = write_hveto_safety_page(ifo, start, end, rounds,
                                    safety_cutoff, **htmlv)
    htmlv.pop('inj_img')
    logger.debug("HTML written to %s" % index)

    htmlv['write_about_file'] = False
    for r in rounds:
        if r.winner.significance >= safety_min:
            htmlv['base'] = './'
            htmlv['html_file'] = 'hveto-round-%04d-summary.html' % r.n
            write_safety_round(ifo, start, end, r, safety_cutoff, **htmlv)
            logger.info('Round %d html written' % r.n)

    run_time = time.time() - jobstart
    logger.info('Wrote index to {:s}, in {:s}'.format(index, outdir))
    logger.info('Safety runtime  %.1f sec' % run_time)

    return stat


def abs_path(p):
    return os.path.abspath(os.path.expanduser(p))


def plot_table(tbl, name, qcpath, tlim, ylim=None, epoch=None):
    """Event table plotter for examples"""
    qcplot = tbl.scatter('time', 'frequency', color='snr', vmin=0, vmax=75)
    ax = qcplot.gca()
    qcplot.suptitle(name, fontsize=18)
    ax.grid(b=True, which='major', color='k', linestyle='solid')
    ax.grid(b=True, which='minor', color='0.06', linestyle='dotted')
    ax.colorbar(label='SNR')
    ax.set_xlim(tlim[0], tlim[1])
    if ylim:
        ax.set_ylim(ylim[0], ylim[1])
    else:
        ax.set_ylim(0, 2048)

    if epoch:
        ax.set_epoch(epoch)

    ax.set_ylabel('Frequency (Hz)')

    fname = name.replace(':', '-') + '.png'
    outfile = os.path.join(qcpath, fname)
    qcplot.savefig(outfile, edgecolor='white', bbox_inches='tight')
    return outfile

if __name__ == "__main__":
    IFO = os.getenv('IFO')

    logger = cli.logger(__process_name__)
    start_time = time.time()
    parser = cli.create_parser(description=__doc__, version=__version__)
    cli.add_ifo_option(parser, required=IFO is None, ifo=IFO)

    parser.add_argument('-v', '--verbose', action='count', default=1,
                        help='increase verbose output')
    parser.add_argument('-q', '--quiet', default=False, action='store_true',
                        help='show only fatal errors')

    cin = parser.add_argument_group('Control options')

    parser.add_argument('-f', '--config-file', action='append', default=[],
                        type=abs_path,
                        help='path to hveto configuration file, can be given '
                             'multiple times (files read in order)')

    cli.add_gps_start_stop_arguments(cin)
    cin.add_argument('-Q', '--qcplot', action='store_true',
                     help='Plot triggers for all input channels')

    pin = parser.add_argument_group('Input options')
    parser.add_argument('-S', '--segment', default=None, type=abs_path,
                        required=True,
                        help='path to segment covering analysis in xml file')
    parser.add_argument('-p', '--primary', default=None, type=abs_path,
                        help='path to primary channel in an hdf5 file')
    parser.add_argument('-a', '--auxiliary', default=None, type=abs_path,
                        help='path to hdf5 file containing all '
                             'auxiliary channel triggers. ')

    pout = parser.add_argument_group('Output options')
    pout.add_argument('-o', '--output-directory',
                      default=os.path.abspath(os.curdir),
                      help='path of output directory, default: %(default)s')

    args = parser.parse_args()

    # read configuration
    cp = config.HvetoConfigParser(ifo=args.ifo)
    cp.read(args.config_file)
    logger.info("Parsed configuration file(s)")

    primary_freq_range = cp.getfloats('primary', 'frequency-range')
    primary = safety_h5_read(args.primary, primary_freq_range)

    aux_freq_range = cp.getfloats('auxiliary', 'frequency-range')
    auxiliary = safety_h5_read(args.auxiliary, aux_freq_range)

    outdir = args.output_directory
    if os.path.exists(outdir):
        if not os.path.isdir(outdir):
            logger.error('Output directory specified {:s} exists but is not'
                         ' a directory.'.format(os.path.abspath(outdir)))
            raise TypeError('Not a directory')
    else:
        os.makedirs(outdir)

    olddir = os.getcwd()
    os.chdir(outdir)

    analysis_seg = DataQualityFlag.read(args.segment)

    # copy input files to results
    copyfile(args.primary, os.path.join(outdir, 'primary.h5'))
    copyfile(args.auxiliary, os.path.join(outdir, 'auxiliary.h5'))
    copyfile(args.segment, os.path.join(outdir, 'segment.xml.gz'))

    safety_calc(cp, logger, outdir, args.config_file, args.ifo,
                args.gpsstart, args.gpsend, start_time)

    os.chdir(olddir)
